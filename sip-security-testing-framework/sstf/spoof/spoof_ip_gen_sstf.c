/*
Program: To generate a given range of addresses and write it to a .csv file readable by SIPp
Author: Hemanth Srinivasan
Year: 2008

NOTE: This program will actually configure the generated range of addresses on a specified interface.
      By this we can achieve not just SIP level but IP level spoofing. 'add' will add these addresses
      to the interface and 'remove' will remove them. Currently the command that will do that,namely
      the system() lib call, is commented. If required uncomment later.
  
      These files have been tailored for SSTF wizard. Pass 'from' or 'to' as the <local_ip>
      eg: sstf command line 
      "./spoof_ip_gen_sstf 192.168.0.0 24 dummy add all from"   -->generates file SIP_from_ip_spoof.csv
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <strings.h>

#define ADD 1
#define REMOVE 2

int main (int argc, char *argv[]) {

   int mask, octet[4];
   char *token, cmdstr[256] = {'\0'}, ip_str[32] = {'\0'};
   int i, j, k, l;
   double addr_count, count = 0;
   char octstr[8] = {'\0'};
   int type = 0, length = 0;
   FILE *scenario_fp;
   char *fp_name;
   char path[] = "../spoof/";
  
   char fname_prefix[] = {"SIP_"};
   char fname_suffix[] = {"_ip_spoof.csv\0"};

   /* SSTF keyword "SIP_from_ip_spoof" "SIP_to_ip_spoof". Generated files will have the same nomeclature with a .csv 
    extension.
   */

   if (argc != 7) {
    printf("Usage: %s <spoof addr> <mask> <interface name> <add/remove> <count|'all'> <local ip>\n", argv[0]);
    exit(0);
   }
 
 /*
  
  length += (strlen(argv[1])+1);
  length += (strlen(argv[2])+1);
  length += (strlen(argv[3])+4);
  length += strlen(path);
  strcpy(fp_name, path);
  strcat(fp_name, argv[1]);
  strcat(fp_name, "_");
  strcat(fp_name, argv[2]);
  strcat(fp_name, "_");
  strcat(fp_name, argv[3]);
  strcat(fp_name, ".csv\0"); 

  fp_name = (char *)calloc(length, sizeof(char));
*/
  
  length = strlen(path)+strlen(fname_prefix)+strlen(argv[6])+strlen(fname_suffix);

  fp_name = (char *)calloc(length, sizeof(char));
  bzero(fp_name, length);
  
  strcpy(fp_name, path);
  strcat(fp_name, fname_prefix);
  strcat(fp_name, argv[6]);
  strcat(fp_name, fname_suffix);

  printf("length=%d strlen=%d\n", length, strlen(fp_name));   
  
  mask = atoi(argv[2]);

  printf("Creating CSV file.... %s\n", fp_name); 

  scenario_fp = fopen(fp_name, "w+");

  printf ("Splitting IP addr string \"%s\" into octets:\n", argv[1]);
  i = 0;
  token = strtok (argv[1], ".");
  while (token != NULL)
  {
    printf ("%s\n", token);
    octet[i++] = atoi(token);
    token = strtok (NULL, ".");
  }
  printf("IP octets are: %d %d %d %d and mask is %d\n", octet[0], octet[1], octet[2], octet[3], mask); 
  if (strcasecmp(argv[5], "all") == 0) {
    addr_count = pow(2, 32 - mask);
    addr_count -= 4;
  
  }
  else {
    addr_count = atoi(argv[5]);
  
  }
  printf("Count is: %lf \n", addr_count); 
  if (strcasecmp(argv[4], "add") == 0) type = ADD;
  if (strcasecmp(argv[4], "remove") == 0) type = REMOVE;
  switch (type) {

   case ADD:    count = 0;
                //fputs("SEQUENTIAL\n", scenario_fp);  //this will be added in the merged csv generated by Strezz.java
                for (i = octet[0]; i < 255; i++) {
                  if (count >= addr_count) break;
                  for (j = octet[1]; j < 255; j++) {
                    if (count >= addr_count) break;
                    for (k = octet[2]; k < 255; k++) {
                      if (count >= addr_count) break;
                      for (l = octet[3]; l < 255; l++) {
                        if (count >= addr_count) break;
                        if (l == 0) continue;
                        strcpy(cmdstr, "/sbin/ip addr add "); 

                        strcat (cmdstr, gcvt(i, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(i, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(j, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(j, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(k, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(k, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(l,3,octstr));

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(l,3,octstr));  
                        if (strcasecmp(ip_str, argv[6]) == 0) {
                          bzero(ip_str, 256);
                          bzero(cmdstr, 256);
			  continue;
                        }

                        //write to scenario file
                        fputs(ip_str, scenario_fp);
                        fputs("\n", scenario_fp);

                        strcat (cmdstr, "/");
                        bzero(octstr, 8);
                        strcat (cmdstr, gcvt(mask,3,octstr)); 
                        strcat (cmdstr, " dev ");
                        strcat (cmdstr, argv[3]);
                        //system(cmdstr);
                        //printf("Command to be executed is %s\n", cmdstr);
                        bzero(cmdstr, 256);
                        bzero(ip_str, 256);
                        count++;

                      }
                    }
                  }
                }
                break;

   case REMOVE: count = 0;
                for (i = octet[0]; i < 255; i++) {
                  if (count >= addr_count) break;
                  for (j = octet[1]; j < 255; j++) {
                    if (count >= addr_count) break;
                    for (k = octet[2]; k < 255; k++) {
                      if (count >= addr_count) break;
                      for (l = octet[3]; l < 255; l++) {
                        if (count >= addr_count) break;
                        if (l == 0) continue;
                        strcpy(cmdstr, "/sbin/ip addr del "); 
                        strcat (cmdstr, gcvt(i, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(i, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(j, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(j, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(k, 3, octstr)); 
                        strcat (cmdstr, ".");

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(k, 3, octstr)); 
                        strcat (ip_str, ".");

                        bzero(octstr, 8);

                        strcat (cmdstr, gcvt(l,3,octstr));

                        //ip addr only for scenario file
                        strcat (ip_str, gcvt(l,3,octstr));  
                        if (strcasecmp(ip_str, argv[6]) == 0) {
			   bzero(cmdstr, 256);
			   bzero(ip_str, 256);
			   continue;
			}

                        strcat (cmdstr, "/");
                        bzero(octstr, 8);
                        strcat (cmdstr, gcvt(mask,3,octstr)); 
                        strcat (cmdstr, " dev ");
                        strcat (cmdstr, argv[3]);
                        //system(cmdstr);
                        //printf("Command to be executed is %s\n", cmdstr);
                        bzero(cmdstr, 256);
                        bzero(ip_str, 256);
                        count++;

                      }
                    }
                  }
                }
                //remove the scenario file
                strcpy (cmdstr, "rm -f ");
                strcat (cmdstr, fp_name);
                //system (cmdstr);
                break;

   default:      printf("Invalid Case!!!\n");
 }  

 fclose(scenario_fp);
 free(fp_name);

} 
